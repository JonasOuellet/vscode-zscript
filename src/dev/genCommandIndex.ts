import * as path from "path";
import { writeFile } from "fs";
import { zConvertHTMLtoPlain, getCommandDocString, getCommandDeclaration } from '../zCommandUtil';
import { zMathFns, zScriptCmds } from '../zscriptCommands';

const indexPath = path.normalize(path.join(__dirname, '..', '..', 'zsc_lang', "index.txt"));


function _setLineMaxCharLength(line: string, maxChar=70, newLineSpaces=0) {
    if (line.length <= maxChar) {
        return line;
    }
    let _spaces = "";
    for (let x = 0; x < newLineSpaces; x++){
        _spaces += " ";
    }
    let finalLine = "";
    let newLine = line;

    let commaFunc = (pos: number) => {
        finalLine += newLine.slice(0, pos+1);
        newLine = newLine.slice(pos+1, newLine.length);
        newLine = newLine.trimLeft();
        newLine = _spaces + newLine;
    };

    let spaceFunc = (pos: number) => {
        finalLine += newLine.slice(0, pos);
        newLine = _spaces + newLine.slice(pos+1, newLine.length);
    };

    while (maxChar < newLine.length) {
        let commaPos = newLine.lastIndexOf(',', maxChar);
        let spacePose = newLine.lastIndexOf(' ', maxChar);

        if (commaPos > spacePose) {
            commaFunc(commaPos);
        } else {
            // when there is no space in the line ?
            if (spacePose < 0) {
                // Find space or comma pose after
                commaPos = newLine.indexOf(',', maxChar);
                spacePose = newLine.indexOf(' ', maxChar);
                
                if (commaPos < spacePose){
                    commaFunc(commaPos);
                    continue;
                }
            }
            spaceFunc(spacePose);
        }

        if (newLine.length) {
            finalLine += '\n';
        }
    }
    finalLine += newLine;

    return finalLine;
}

function splitTextLine(text: string, maxChar: number=90, maxCommaLength: number=10){
    let outLine = "";
    let lines = text.split("\n");
    lines.forEach((line, index) => {
        outLine += _setLineMaxCharLength(line);
        if (index < lines.length - 1) {
            outLine += '\n';
        }
    });
    return outLine;
}


function writeIndexFile(){
    let index = `/********************************
* This file is automatically generated.
* DO NOT MODIFY THIS FILE
*
* ZScript Command Definitions
* http://docs.pixologic.com/user-guide/customizing-zbrush/zscripting/command-reference/
*
********************************/\n\n\n`;
    
    for (let obj of [zScriptCmds, zMathFns]){
        for (let cmd in obj){
            let zcommand = obj[cmd];
    
            let docString = zConvertHTMLtoPlain(getCommandDocString(zcommand));
            docString = splitTextLine(docString);
            docString = docString.replace(/\n/g, "\n* ");
            docString = "/**\n* " + docString + "\n*/\n";
    
            index += docString;
            index += splitTextLine(getCommandDeclaration(cmd, zcommand));
            index += "\n\n";
            
        }
    }
    writeFile(indexPath, index, (err) => {
        if (err){
            console.log(err);
        }else{
            console.log("Command file successfully writed here: \"" + indexPath + "\"");
        }        
    });
}

writeIndexFile();